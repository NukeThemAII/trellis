#!/usr/bin/env node
import { readFileSync, writeFileSync, mkdirSync, existsSync, readdirSync } from "fs";
import { dirname, join, parse } from "path";
import { fileURLToPath } from "url";
import prettier from "prettier";

const __dirname = dirname(fileURLToPath(import.meta.url));
const repoRoot = join(__dirname, "..");

const ABI_OUTPUT_DIR = join(repoRoot, "frontend", "contracts", "abi");
const DEPLOYMENTS_DIR = join(repoRoot, "contracts", "deployments");
const DEPLOYED_CONTRACTS_PATH = join(repoRoot, "frontend", "contracts", "deployedContracts.ts");

const CONTRACTS = [
  {
    name: "TrellisVault",
    artifact: join(repoRoot, "contracts", "out", "TrellisVault.sol", "TrellisVault.json"),
    exportName: "trellisVaultAbi",
  },
  {
    name: "StrategyERC4626",
    artifact: join(repoRoot, "contracts", "out", "StrategyERC4626.sol", "StrategyERC4626.json"),
    exportName: "strategyErc4626Abi",
  },
];

const ABI_EXPORTS = CONTRACTS.map(({ exportName }) => exportName);

const BASE_CHAIN_ID = 8453;
const BASE_SEPOLIA_CHAIN_ID = 84532;

const maybeAddress = (value) =>
  typeof value === "string" && value.startsWith("0x") && value.length === 42 ? value : undefined;

const envFallbacks = () => {
  const baseVault = maybeAddress(process.env.NEXT_PUBLIC_DEFAULT_VAULT_ADDRESS);
  const baseStrategy = maybeAddress(process.env.NEXT_PUBLIC_DEFAULT_STRATEGY_ADDRESS);
  const baseSepoliaVault = maybeAddress(process.env.NEXT_PUBLIC_DEFAULT_VAULT_SEPOLIA_ADDRESS);
  const baseSepoliaStrategy = maybeAddress(process.env.NEXT_PUBLIC_DEFAULT_STRATEGY_SEPOLIA_ADDRESS);

  const result = {};

  if (baseVault || baseStrategy) {
    result[BASE_CHAIN_ID] = {
      TrellisVault: baseVault,
      StrategyERC4626: baseStrategy,
    };
  }

  if (baseSepoliaVault || baseSepoliaStrategy) {
    result[BASE_SEPOLIA_CHAIN_ID] = {
      TrellisVault: baseSepoliaVault,
      StrategyERC4626: baseSepoliaStrategy,
    };
  }

  return result;
};

const formatTs = async (source) => prettier.format(source, { parser: "typescript" });

const ensureArtifactsPresent = () => {
  const missing = CONTRACTS.filter(({ artifact }) => !existsSync(artifact));
  if (missing.length > 0) {
    const names = missing.map(({ name, artifact }) => `- ${name}: ${relativePath(artifact)}`).join("\n");
    throw new Error(
      `Missing build artifacts for:\n${names}\nRun "pnpm contracts:build" (or "forge build") before generating frontend artifacts.`,
    );
  }
};

const relativePath = (path) => path.replace(`${repoRoot}${join.sep}`, "");

const loadAbi = (artifactPath) => {
  const json = JSON.parse(readFileSync(artifactPath, "utf8"));
  return json.abi ?? [];
};

const writeAbiExports = async () => {
  mkdirSync(ABI_OUTPUT_DIR, { recursive: true });

  for (const { name, artifact, exportName } of CONTRACTS) {
    const abi = loadAbi(artifact);
    const output = await formatTs(
      [
        "/**",
        ` * ABI for ${name} (auto-generated by scripts/generate-frontend-artifacts.mjs).`,
        " * Do not edit manually.",
        " */",
        `export const ${exportName} = ${JSON.stringify(abi, null, 2)} as const;`,
        `export type ${name}Abi = typeof ${exportName};`,
        "",
      ].join("\n"),
    );
    const outputPath = join(ABI_OUTPUT_DIR, `${exportName}.ts`);
    writeFileSync(outputPath, output);
    console.log(`✔ Wrote ${relativePath(outputPath)}`);
  }
};

const readDeploymentFile = (filePath) => {
  try {
    const raw = readFileSync(filePath, "utf8");
    return JSON.parse(raw);
  } catch (error) {
    console.warn(`⚠️  Could not parse ${relativePath(filePath)}: ${error.message}`);
    return null;
  }
};

const collectDeployments = () => {
  const deployments = {};

  if (existsSync(DEPLOYMENTS_DIR)) {
    for (const entry of readdirSync(DEPLOYMENTS_DIR)) {
      if (!entry.endsWith(".json")) continue;
      const chainId = Number(parse(entry).name);
      if (!Number.isFinite(chainId)) continue;

      const json = readDeploymentFile(join(DEPLOYMENTS_DIR, entry));
      if (!json) continue;

      const chainContracts = {};

      for (const [address, contractName] of Object.entries(json)) {
        if (contractName === "networkName") continue;
        if (!maybeAddress(address)) continue;
        if (!CONTRACTS.find(({ name }) => name === contractName)) continue;
        chainContracts[contractName] = address;
      }

      if (Object.keys(chainContracts).length > 0) {
        deployments[chainId] = { ...(deployments[chainId] || {}), ...chainContracts };
      }
    }
  }

  // Merge env fallbacks without overriding discovered deployments
  const fallbacks = envFallbacks();
  for (const [chainId, contracts] of Object.entries(fallbacks)) {
    const numericChainId = Number(chainId);
    deployments[numericChainId] = { ...(deployments[numericChainId] || {}), ...contracts };
  }

  return deployments;
};

const generateDeployedContractsFile = async (deployments) => {
  const lines = [
    "/**",
    " * Deployed contracts map (auto-generated by scripts/generate-frontend-artifacts.mjs).",
    " * Do not edit manually.",
    " */",
    `import { ${ABI_EXPORTS.join(", ")} } from "./abi";`,
    'import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract";',
    "",
  ];

  const bodyEntries = Object.entries(deployments).map(([chainId, contracts]) => {
    const contractEntries = Object.entries(contracts)
      .filter(([, address]) => Boolean(address))
      .map(
        ([name, address]) =>
          `    ${name}: {\n      address: "${address}",\n      abi: ${name === "TrellisVault" ? "trellisVaultAbi" : "strategyErc4626Abi"},\n      inheritedFunctions: {},\n    }`,
      );

    if (contractEntries.length === 0) return `  ${chainId}: {},`;

    return `  ${chainId}: {\n${contractEntries.join(",\n")}\n  },`;
  });

  const deployedContractsConst = [
    "const deployedContracts = {",
    bodyEntries.length > 0 ? bodyEntries.join("\n") : "",
    "} as const satisfies GenericContractsDeclaration;",
    "",
    "export default deployedContracts;",
    "",
  ];

  const output = await formatTs([...lines, ...deployedContractsConst].join("\n"));
  writeFileSync(DEPLOYED_CONTRACTS_PATH, output);
  console.log(`✔ Wrote ${relativePath(DEPLOYED_CONTRACTS_PATH)}`);
};

async function main() {
  ensureArtifactsPresent();
  await writeAbiExports();

  const deployments = collectDeployments();
  await generateDeployedContractsFile(deployments);
}

try {
  await main();
} catch (error) {
  console.error(error instanceof Error ? error.message : error);
  process.exit(1);
}
